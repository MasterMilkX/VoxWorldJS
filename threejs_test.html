<html>
    <head>
        <title>Three.js Test</title>
        <!-- set the css -->
        <style>
            body{
				background-color:#ffffff;
				text-align: center;
			}
			#game{
				width:480px;
				height:320px;
				border:2px solid #000000;
				background-color:#dedede;
				padding-left: 0;
				padding-right: 0;
				margin-left: auto;
				margin-right: auto;

				/* scale up pixels */
				image-rendering: -moz-crisp-edges;
		        image-rendering: -webkit-crisp-edges;
		        image-rendering: pixelated;
		        image-rendering: crisp-edges;
			}
            canvas{
                border:2px solid #000000;
                margin:auto;
            }
            #debugBar{
                margin-bottom:1em;
            }
        </style>

        <!-- import three.js -->
        <script src="js/three.js"></script>

    </head>
    <body>

        <!-- content -->
        <div style="margin:1.5em 0 1em 0;color:#000;font-size:24px;">Three.js Test</div>
        <div id="debugBar">
            <p id="debug" style="color:#000">...</p>
            <button onclick="ROTATE=!ROTATE">Rotate</button>
        </div>
		<!-- <canvas id='renderScreen'>Browser does not support HTML5 canvas</canvas> -->
    
    
        <!-- script -->
        <script>
            //set up the canvas
            const scene = new THREE.Scene();
            scene.background = new THREE.Color( 0xdddddd );
            const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

            const renderer = new THREE.WebGLRenderer();
            renderer.setSize( window.innerWidth/2, window.innerHeight/2 );
            document.body.appendChild( renderer.domElement );

            //load a texture loader
            const loader = new THREE.TextureLoader();

            //add a light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.9);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(10, 20, 0); // x, y, z
            scene.add(directionalLight);

            //draw a box
            // const geometry = new THREE.BoxGeometry( 1, 1, 1 );
            // const material = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
            // const cube = new THREE.Mesh( geometry, material );
            // scene.add( cube );

            // camera.position.z = 5;

            //make a 2d castle
            function castle2d(pos=[0,0,0]){
                let binCastle = [[1,0,1,0,1],[1,1,1,1,1],[1,1,1,1,1],[0,1,1,1,0],[0,1,1,1,0],[0,1,1,1,0],[0,1,1,1,0]]
                
                //get the castle properties
                let castleDim = [binCastle.length, binCastle[0].length]; //w,h
                let castleCen = [castleDim[0]/2, castleDim[1]/2]; //x,y

                //load texture for castle
                let castleTex = loader.load('textures/stonebrick.png');

                //build the castle
                let castleObj = new THREE.Group();
                for(let i = 0; i < binCastle.length; i++){
                    for(let j = 0; j < binCastle[i].length; j++){
                        if(binCastle[i][j] == 1){
                            let geometry = new THREE.BoxGeometry( 1, 1, 1 );
                            let  material = new THREE.MeshBasicMaterial({map: castleTex});
                            let cube = new THREE.Mesh( geometry, material );
                            cube.position.set(j+pos[0]-castleCen[0],castleDim[1]-i+pos[1], 0+pos[2]);  //top down of the array (reverse y)
                            castleObj.add(cube);
                        }
                    }
                }

                //add the castle to the scene
                scene.add(castleObj)
            }


            //make the structure given a 3d array
            //represented as y,x,z in the 3d array
            function make3dStructure(arr3d,offset=[0,0,0]){
                //default offset
                let def_off = [0.5,-0.5,0.5];
                let off = [offset[0]+def_off[0],offset[1]+def_off[1],offset[2]+def_off[2]];

                //get the structure properties
                let structDim = [arr3d.length, arr3d[0].length, arr3d[0][0].length]; //w,h,d
                let structCen = [structDim[0]/2, structDim[1]/2, structDim[2]/2]; //x,y,z

                //load the textures for the structure
                let structTex = {};
                structTex[0] = null;
                structTex[1] = loader.load('textures/stonebrick.png');
                structTex[2] = loader.load('textures/stonebrick_cracked.png');
                structTex[3] = loader.load('textures/coal_block.png');
                
                //build the structure
                let structObj = new THREE.Group();
                for(let i = 0; i < arr3d.length; i++){
                    for(let j = 0; j < arr3d[i].length; j++){
                        for(let k = 0; k < arr3d[i][j].length; k++){
                            if(arr3d[i][j][k] != 0){
                                let geometry = new THREE.BoxGeometry( 1, 1, 1 );
                                let  material = new THREE.MeshBasicMaterial({map: structTex[arr3d[i][j][k]]});
                                let cube = new THREE.Mesh( geometry, material );
                                cube.position.set(j+off[0]-structCen[1],structDim[0]-i+off[1],k+off[2]-structCen[2]);  //top down of the array (reverse y)
                                structObj.add(cube);
                            }
                        }
                    }
                }

                document.getElementById("debug").innerHTML = `Center:${structCen} | Offset:${off} | Dimensions:${structDim}`;

                //add the structure to the scene
                scene.add(structObj);
                
            }



            // Add a cube to the scene
            // god i love this fucking cube so much - look at it spin!!!!
            const geometry = new THREE.BoxGeometry(1,1,1); // width, height, depth
            const material = new THREE.MeshLambertMaterial({ color: 0xfb8e00 });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(0, 0.5, 0); // Optional, 0,0,0 is the default
            scene.add(mesh);

            //add a plane to act as the ground
            const planeGeometry = new THREE.PlaneGeometry( 100, 100, 1 );
            const planeMaterial = new THREE.MeshBasicMaterial( {color: 0x062D03, side: THREE.DoubleSide} );
            const plane = new THREE.Mesh( planeGeometry, planeMaterial );
            plane.position.set(0,0,0);
            plane.rotation.x = Math.PI / 2;
            scene.add( plane );

            var OFFSET = [0,0,0]
            // castle2d(OFFSET);
            let s1 = [[[3,3,3,3,3],[3,3,3,3,3],[3,3,3,3,3]],[[1,0,1,0,1],[1,0,1,0,1],[1,0,1,0,1]],[[2,1,2,1,2],[1,0,0,0,1],[0,0,0,0,0]],[[0,1,0,1,0],[1,1,1,1,1],[1,1,1,1,1]]];
            let s2 = [[[0,0,0,0,0],[0,3,3,3,0],[0,3,3,3,0],[0,3,3,3,0],[0,0,0,0,0]],[[3,3,3,3,3],[3,3,3,3,3],[3,3,3,3,3],[3,3,3,3,3],[3,3,3,3,3]],[[1,1,1,1,1],[0,3,3,3,0],[0,3,3,3,0],[0,3,3,3,0],[1,1,1,1,1]],[[1,0,0,0,1],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[1,0,0,0,1]],[[1,0,0,0,1],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[1,0,0,0,1]],[[1,0,0,0,1],[0,0,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[1,0,0,0,1]],[[2,0,0,0,2],[1,0,0,0,1],[2,0,0,0,1],[2,0,0,0,1],[1,0,0,0,2]]];
            make3dStructure(s2,OFFSET);

            camera.position.y = 5;

            function rotateCam(angle,radius=10){
                camera.lookAt(0,5,0);
                camera.position.x = radius * Math.cos( angle );  
                camera.position.z = radius * Math.sin( angle ); 
            }
            
            
            var turnLeft = false;
            var turnRight = false;
            var ANGLE = 0;
            var RADIUS = 12;
            var ROTATE = false;
            
            //set starting position
            camera.lookAt(0,5,0);
            camera.position.x = 0;
            camera.position.y = 5;
            camera.position.z = RADIUS;

            //render and control the scene
            function main() {
                requestAnimationFrame( main );
                renderer.render( scene, camera );

                if(ROTATE)
                    rotateCam(ANGLE+=1/60,RADIUS)

                // document.getElementById("debug").innerHTML = "ANGLE: " + ANGLE;
            }


            /////////////////   HTML5 FUNCTIONS  //////////////////

            //determine if valud key to press
            document.body.addEventListener("keydown", function (e) {
                if(e.keyCode == 37){ //left key
                    turnLeft = true;
                }else if(e.keyCode == 39){ //right key
                    turnRight = true;
                }
            });

            //check for key released
            document.body.addEventListener("keyup", function (e) {
                if(e.keyCode == 37){ //left key
                    turnLeft = false;
                }else if(e.keyCode == 39){ //right key
                    turnRight = false;
                }
            });

            //prevent scrolling with the game
            window.addEventListener("keydown", function(e) {
                // space and arrow keys
                if(([32, 37, 38, 39, 40].indexOf(e.keyCode) > -1)){
                    e.preventDefault();
                }
            }, false);


            main();




        </script>
    </body>
</html>